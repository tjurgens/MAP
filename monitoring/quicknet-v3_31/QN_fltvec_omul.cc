const char* QN_fltvec_omul_rcsid = "$Header: /u/drspeech/repos/quicknet2/QN_fltvec_omul.cc,v 1.2 2004/04/20 00:57:13 davidj Exp $";

// Floating point vector utility routines for QuickNet
// Online-mode floating point matrix ops

#include <assert.h>
#include "QN_fltvec.h"

/* Code generated by ./gen_mul_mfvf_vf */
/* n_rows=4 n_cols=4 */



void
qn_pp_mul_mfvf_vf(const size_t rows, const size_t cols,
		  const float* mat, const float* vec, float* res)
{
	const float *rowp = mat;
	const int RB = 4;
	const int RC = 4;
	size_t i;

	const size_t last_block_row = rows & ~(RB-1);
	const float* end_inp = vec + cols;

	const float* end_col_unrollp = vec + (cols & ~(RC-1));
	for (i = 0 ; i != last_block_row; i += RB)
	{
		float rsum0 = 0.0;
		const float* rp0 = rowp;
		float rsum1 = 0.0;
		const float* rp1 = rp0 + cols;
		float rsum2 = 0.0;
		const float* rp2 = rp1 + cols;
		float rsum3 = 0.0;
		const float* rp3 = rp2 + cols;

		const float* inp;
		for (inp = vec; inp != end_col_unrollp; inp += RC)
		{
			const float velem0 = inp[0];
			const float velem1 = inp[1];
			const float velem2 = inp[2];
			const float velem3 = inp[3];

			rsum0 += velem0 * rp0[0];
			rsum1 += velem0 * rp1[0];
			rsum2 += velem0 * rp2[0];
			rsum3 += velem0 * rp3[0];

			rsum0 += velem1 * rp0[1];
			rsum1 += velem1 * rp1[1];
			rsum2 += velem1 * rp2[1];
			rsum3 += velem1 * rp3[1];

			rsum0 += velem2 * rp0[2];
			rsum1 += velem2 * rp1[2];
			rsum2 += velem2 * rp2[2];
			rsum3 += velem2 * rp3[2];

			rsum0 += velem3 * rp0[3];
			rsum1 += velem3 * rp1[3];
			rsum2 += velem3 * rp2[3];
			rsum3 += velem3 * rp3[3];
			rp0 += RC;
			rp1 += RC;
			rp2 += RC;
			rp3 += RC;
		}

		for ( ; inp != end_inp; inp++)
		{
			const float velem = *inp;

			rsum0 += velem * (*rp0++);
			rsum1 += velem * (*rp1++);
			rsum2 += velem * (*rp2++);
			rsum3 += velem * (*rp3++);
		}

		res[0] = rsum0;
		res[1] = rsum1;
		res[2] = rsum2;
		res[3] = rsum3;

		res += RB;

		rowp = rp3;
	}

	for ( ; i<rows; i++)
	{
		*res++ = qn_pp_mulsum_vfvf_f(cols, rowp, vec);
		rowp += cols;
	}
}

float
qn_pp_mulsum_vfvf_f(const size_t n, const float* avec, const float* bvec)
{
    register float sum0 = 0.0;
    register float sum1 = 0.0;

    const float *all_endp = avec + n;
    const float *smallblock_endp = avec + (n & ~3);
    const float *bigblock_endp = avec + (n & ~15);

    while (avec != bigblock_endp)
    {
        sum0 += avec[0] * bvec[0];
        sum1 += avec[1] * bvec[1];
        sum0 += avec[2] * bvec[2];
        sum1 += avec[3] * bvec[3];
        sum0 += avec[4] * bvec[4];
        sum1 += avec[5] * bvec[5];
        sum0 += avec[6] * bvec[6];
        sum1 += avec[7] * bvec[7];
        sum0 += avec[8] * bvec[8];
        sum1 += avec[9] * bvec[9];
        sum0 += avec[10] * bvec[10];
        sum1 += avec[11] * bvec[11];
        sum0 += avec[12] * bvec[12];
        sum1 += avec[13] * bvec[13];
        sum0 += avec[14] * bvec[14];
        sum1 += avec[15] * bvec[15];

        avec += 16; bvec += 16;
    }

    while (avec != smallblock_endp)
    {
        sum0 += avec[0] * bvec[0];
        sum1 += avec[1] * bvec[1];
        sum0 += avec[2] * bvec[2];
        sum1 += avec[3] * bvec[3];

        avec += 4; bvec += 4;
    }

    sum0 += sum1;

    /* Do trailing portion in naive loop. */
    while (avec != all_endp)
        sum0 += (*avec++) * (*bvec++);

    return sum0;
}

void
qn_pp_mulacc_fvfvf_mf(const size_t rows, const size_t cols,
		      const float scale, const float* in_vec,
		      const float* in_vec_t, float *mat)
{
    float* rowp = mat;
    const float* end_rowp = in_vec + rows;
    const float* end_rowb2p = in_vec + (rows & ~1);
    const float* end_colp = in_vec_t + cols;

    const float* end_colb4p = in_vec_t + (cols & ~3);

    while(in_vec != end_rowb2p)
    {
        const float rs0 = scale * in_vec[0];
        float* rp0 = rowp;
        const float rs1 = scale * in_vec[1];
        float* rp1 = rp0 + cols;

        const float* cp = in_vec_t;

        while (cp != end_colb4p)
        {
            const float c0 = cp[0];
            const float c1 = cp[1];
            const float c2 = cp[2];
            const float c3 = cp[3];

            float v0_0;
            float v0_1;
            float v0_2;
            float v0_3;
            float v1_0;
            float v1_1;
            float v1_2;
            float v1_3;

            v0_0 = rs0 * c0 + rp0[0];
            v0_1 = rs0 * c1 + rp0[1];
            v0_2 = rs0 * c2 + rp0[2];
            v0_3 = rs0 * c3 + rp0[3];
            rp0[0] = v0_0;
            rp0[1] = v0_1;
            rp0[2] = v0_2;
            rp0[3] = v0_3;
            rp0 += 4;

            v1_0 = rs1 * c0 + rp1[0];
            v1_1 = rs1 * c1 + rp1[1];
            v1_2 = rs1 * c2 + rp1[2];
            v1_3 = rs1 * c3 + rp1[3];
            rp1[0] = v1_0;
            rp1[1] = v1_1;
            rp1[2] = v1_2;
            rp1[3] = v1_3;
            rp1 += 4;

            cp += 4;
        }

        while (cp != end_colp)
        {
            const float c0 = *cp++;
            *rp0++ += rs0 * c0;
            *rp1++ += rs1 * c0;
        }

        in_vec += 2;
        rowp = rp1;
    }
    while (in_vec != end_rowp)
    {
        qn_pp_muladd_vffvf_vf(cols, in_vec_t, scale * (*in_vec), rowp, rowp);
        rowp += cols;
        in_vec++;
    }
}

void
qn_pp_muladd_vffvf_vf(const size_t n,
		      const float* xvec, const float s, const float *yvec,
		      float* res)
{
    const float *const x_end_b8p = xvec + (n & ~7);
    const float *const x_end_b2p = xvec + (n & ~1);

    while (xvec != x_end_b8p)
    {
        const float sum0 = s * xvec[0] + yvec[0];
        const float sum1 = s * xvec[1] + yvec[1];
        const float sum2 = s * xvec[2] + yvec[2];
        const float sum3 = s * xvec[3] + yvec[3];
        const float sum4 = s * xvec[4] + yvec[4];
        const float sum5 = s * xvec[5] + yvec[5];
        const float sum6 = s * xvec[6] + yvec[6];
        const float sum7 = s * xvec[7] + yvec[7];

        xvec += 8; yvec += 8;

        res[0] =  sum0;
        res[1] =  sum1;
        res[2] =  sum2;
        res[3] =  sum3;
        res[4] =  sum4;
        res[5] =  sum5;
        res[6] =  sum6;
        res[7] =  sum7;

        res += 8;
    }

    /* Do remainder in pairs. */
    while (xvec != x_end_b2p)
    {
        const float sum0 = s * xvec[0] + yvec[0];
        const float sum1 = s * xvec[1] + yvec[1];

        xvec += 2; yvec += 2;

        res[0] =  sum0;
        res[1] =  sum1;

        res += 2;
    }

    /* Do last one. */
    if (n & 1)
    {
        *res = s * (*xvec) + (*yvec);
    }
}

void
qn_pp_mul_vfmf_vf(const size_t rows, const size_t cols,
		  const float* vec, const float* mat, float* res)
{
    const float* end_inp = vec + rows;
    size_t i = 0;

    size_t last_b8_col;
    last_b8_col = cols & ~(7);
    for ( ; i != last_b8_col; i += 8)
    {
        const float* inp = vec;
        const float* colp = mat;

        float csum0 = 0.0;
        float csum1 = 0.0;
        float csum2 = 0.0;
        float csum3 = 0.0;
        float csum4 = 0.0;
        float csum5 = 0.0;
        float csum6 = 0.0;
        float csum7 = 0.0;

        while (inp != end_inp)
        {
            const float velem = *inp++;

            csum0 += velem * colp[0];
            csum1 += velem * colp[1];
            csum2 += velem * colp[2];
            csum3 += velem * colp[3];
            csum4 += velem * colp[4];
            csum5 += velem * colp[5];
            csum6 += velem * colp[6];
            csum7 += velem * colp[7];

            colp += cols;
        }
        res[0] = csum0;
        res[1] = csum1;
        res[2] = csum2;
        res[3] = csum3;
        res[4] = csum4;
        res[5] = csum5;
        res[6] = csum6;
        res[7] = csum7;

        res += 8;

        mat += 8;
    }

    if (cols & 4)
    {
        const float* inp = vec;
        const float* colp = mat;

        float csum0 = 0.0;
        float csum1 = 0.0;
        float csum2 = 0.0;
        float csum3 = 0.0;

        while (inp != end_inp)
        {
            const float velem = *inp++;

            csum0 += velem * colp[0];
            csum1 += velem * colp[1];
            csum2 += velem * colp[2];
            csum3 += velem * colp[3];

            colp += cols;
        }
        res[0] = csum0;
        res[1] = csum1;
        res[2] = csum2;
        res[3] = csum3;

        res += 4;

        mat += 4;
    }

    if (cols & 2)
    {
        const float* inp = vec;
        const float* colp = mat;

        float csum0 = 0.0;
        float csum1 = 0.0;

        while (inp != end_inp)
        {
            const float velem = *inp++;

            csum0 += velem * colp[0];
            csum1 += velem * colp[1];

            colp += cols;
        }
        res[0] = csum0;
        res[1] = csum1;

        res += 2;

        mat += 2;
    }

    if (cols & 1)
    {
        const float* inp = vec;
        const float* colp = mat;

        float csum0 = 0.0;

        while (inp != end_inp)
        {
            const float velem = *inp++;

            csum0 += velem * colp[0];

            colp += cols;
        }
        res[0] = csum0;

        res += 1;

        mat += 1;
    }

}

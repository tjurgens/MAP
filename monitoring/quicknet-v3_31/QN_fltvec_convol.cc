const char* QN_fltvec_convol_rcsid = "$Header: /u/drspeech/repos/quicknet2/QN_fltvec_convol.cc,v 1.3 2007/02/19 09:06:22 davidj Exp $";

#include <QN_config.h>
#include <stddef.h>
#include <assert.h>
#include <stdio.h>
#include "QN_types.h"
#include "QN_fltvec.h"

// A vector convolution routine, y = h * x
// Originally generated by a program, not written by hand
// Generated by /u/bedk/speech/src/convol/gen_php_convol

/////////////////////////////////////
// *********************************
// ******* DOES NOT WORK!!!! *******
// *********************************
// davidj - 2007/02/18
/////////////////////////////////////


void
qn_pp_convol_vfvf_vf(size_t h_len, size_t x_len, const float *h,
	       const float *x, float *y) {
  const size_t h_ntail = h_len & (4 - 1);
  const size_t x_ntail = x_len & (4 - 1);
  const float *const h_tailp = h + h_len - h_ntail;
  const float *hp;

  const float *x_startp = x;
  const float *xp;

  const float *const y_triendp = y + h_len - h_ntail;
  const float *const y_tailp = y + x_len - x_ntail;
  const float *const y_endp  = y + x_len;

  float h0;
  float h1;
  float h2;
  float h3;
  float x0;
  float x1;
  float x2;
  float x3;
  float y0;
  float y1;
  float y2;
  float y3;

  /* die if the filter is longer than the signal */
  assert(x_len >= h_len);

  while (y != y_triendp) {
    hp = h;
    xp = x_startp;

    h0 = *(hp + 0);
    h1 = *(hp + 1);
    h2 = *(hp + 2);
    h3 = *(hp + 3);
    x0 = *(xp + 0);
    x1 = *(xp + 1);
    x2 = *(xp + 2);
    x3 = *(xp + 3);
    y0 = 0.0f;
    y1 = 0.0f;
    y2 = 0.0f;
    y3 = 0.0f;

    /* do the blocks */
    while (xp != x) {
      xp -= 4;

      y3 += h0 * x3;
      y2 += h0 * x2;
      y1 += h0 * x1;
      y0 += h0 * x0;
      x3 = *(xp + 3);

      y3 += h1 * x2;
      y2 += h1 * x1;
      y1 += h1 * x0;
      y0 += h1 * x3;
      x2 = *(xp + 2);

      y3 += h2 * x1;
      y2 += h2 * x0;
      y1 += h2 * x3;
      y0 += h2 * x2;
      x1 = *(xp + 1);

      y3 += h3 * x0;
      y2 += h3 * x3;
      y1 += h3 * x2;
      y0 += h3 * x1;
      x0 = *(xp + 0);

      h0 = *(hp + 4);
      h1 = *(hp + 5);
      h2 = *(hp + 6);
      h3 = *(hp + 7);
      hp += 4;
    }

    y3 += h0 * x3;
    y2 += h0 * x2;
    y1 += h0 * x1;
    y0 += h0 * x0;
    y3 += h1 * x2;
    y2 += h1 * x1;
    y1 += h1 * x0;
    y3 += h2 * x1;
    y2 += h2 * x0;
    y3 += h3 * x0;

    *(y + 0) = y0;
    *(y + 1) = y1;
    *(y + 2) = y2;
    *(y + 3) = y3;
    y += 4;
    x_startp += 4;
  }

  if (h_ntail != 0 && y != y_tailp) {
    hp = h;
    xp = x_startp;

    h0 = *(hp + 0);
    h1 = *(hp + 1);
    h2 = *(hp + 2);
    h3 = *(hp + 3);
    x0 = *(xp + 0);
    x1 = *(xp + 1);
    x2 = *(xp + 2);
    x3 = *(xp + 3);
    y0 = 0.0f;
    y1 = 0.0f;
    y2 = 0.0f;
    y3 = 0.0f;

    /* do the blocks */
    while (hp != h_tailp) {
      xp -= 4;

      y3 += h0 * x3;
      y2 += h0 * x2;
      y1 += h0 * x1;
      y0 += h0 * x0;
      x3 = *(xp + 3);

      y3 += h1 * x2;
      y2 += h1 * x1;
      y1 += h1 * x0;
      y0 += h1 * x3;
      x2 = *(xp + 2);

      y3 += h2 * x1;
      y2 += h2 * x0;
      y1 += h2 * x3;
      y0 += h2 * x2;
      x1 = *(xp + 1);

      y3 += h3 * x0;
      y2 += h3 * x3;
      y1 += h3 * x2;
      y0 += h3 * x1;
      x0 = *(xp + 0);

      h0 = *(hp + 4);
      h1 = *(hp + 5);
      h2 = *(hp + 6);
      h3 = *(hp + 7);
      hp += 4;
    }

    switch (h_ntail) {
    case 3:
      y3 += h2 * x1;
      y2 += h2 * x0;
      /* NO break */
    case 2:
      y3 += h1 * x2;
      y2 += h1 * x1;
      y1 += h1 * x0;
      /* NO break */
    case 1:
      y3 += h0 * x3;
      y2 += h0 * x2;
      y1 += h0 * x1;
      y0 += h0 * x0;
      break;
    default:
      assert(0);
      break;
    }

    *(y + 0) = y0;
    *(y + 1) = y1;
    *(y + 2) = y2;
    *(y + 3) = y3;
    y += 4;
    x_startp += 4;
  }

  while (y != y_tailp) {
    hp = h;
    xp = x_startp;

    h0 = *(hp + 0);
    h1 = *(hp + 1);
    h2 = *(hp + 2);
    h3 = *(hp + 3);
    x0 = *(xp + 0);
    x1 = *(xp + 1);
    x2 = *(xp + 2);
    x3 = *(xp + 3);
    y0 = 0.0f;
    y1 = 0.0f;
    y2 = 0.0f;
    y3 = 0.0f;

    /* do the blocks */
    while (hp != h_tailp) {
      xp -= 4;

      y3 += h0 * x3;
      y2 += h0 * x2;
      y1 += h0 * x1;
      y0 += h0 * x0;
      x3 = *(xp + 3);

      y3 += h1 * x2;
      y2 += h1 * x1;
      y1 += h1 * x0;
      y0 += h1 * x3;
      x2 = *(xp + 2);

      y3 += h2 * x1;
      y2 += h2 * x0;
      y1 += h2 * x3;
      y0 += h2 * x2;
      x1 = *(xp + 1);

      y3 += h3 * x0;
      y2 += h3 * x3;
      y1 += h3 * x2;
      y0 += h3 * x1;
      x0 = *(xp + 0);

      h0 = *(hp + 4);
      h1 = *(hp + 5);
      h2 = *(hp + 6);
      h3 = *(hp + 7);
      hp += 4;
    }

    if (h_ntail == 0) goto done;
    xp -= 4;
    y3 += h0 * x3;
    y2 += h0 * x2;
    y1 += h0 * x1;
    y0 += h0 * x0;

    if (h_ntail == 1) goto done;
    x3 = *(xp + 3);
    y3 += h1 * x2;
    y2 += h1 * x1;
    y1 += h1 * x0;
    y0 += h1 * x3;

    if (h_ntail == 2) goto done;
    x2 = *(xp + 2);
    y3 += h2 * x1;
    y2 += h2 * x0;
    y1 += h2 * x3;
    y0 += h2 * x2;

  done:
    *(y + 0) = y0;
    *(y + 1) = y1;
    *(y + 2) = y2;
    *(y + 3) = y3;
    y += 4;
    x_startp += 4;
  }

  while (y != y_endp) {
    hp = h;
    xp = x_startp++;

    h0 = *(hp + 0);
    h1 = *(hp + 1);
    h2 = *(hp + 2);
    h3 = *(hp + 3);
    y0 = 0.0f;

    while (hp != h_tailp) {
      xp -= 4;
      x0 = *(xp+4);
      x1 = *(xp + 1);
      x2 = *(xp + 2);
      x3 = *(xp + 3);

      y0 += h0 * x0;
      y0 += h1 * x3;
      y0 += h2 * x2;
      y0 += h3 * x1;

      h0 = *(hp + 4);
      h1 = *(hp + 5);
      h2 = *(hp + 6);
      h3 = *(hp + 7);
      hp += 4;
    }
    
    /* Need to catch the case where the signal length is close (within
       the blocking factor) to the filter length */

    if (h_ntail == 0) goto done1;
    y0 += h0 * *xp;

    if ((h_ntail == 1) || (xp == x)) goto done1;
    y0 += h1 * *--xp;

    if ((h_ntail == 2) || (xp == x)) goto done1;
    y0 += h2 * *--xp;

  done1:
    *y++ = y0;
  }
}

